#!/usr/bin/env python
#
# -*- mode:python; sh-basic-offset:4; indent-tabs-mode:nil; coding:utf-8 -*-
# vim:set tabstop=4 softtabstop=4 expandtab shiftwidth=4 fileencoding=utf-8:
#
# Copyright (c) 2012, Jorge A Gallegos <kad@blegh.net>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import argparse
import boto
from dateutil import parser
import grp
import json
import logging
import threading
import os
import pwd
import socket
import sys
import subprocess
import StringIO
import time
from Queue import Queue
import re

log = logging.getLogger('tableslurp')
stderr = logging.StreamHandler()
stderr.setFormatter(logging.Formatter(
    '%(name)s [%(asctime)s] %(levelname)s %(message)s'))
log.addHandler(stderr)
if os.environ.get('TDEBUG', False):
    log.setLevel(logging.DEBUG)
else:
    log.setLevel(logging.INFO)


class DownloadCounter(object):
    filename = None
    attemptcount = 0

    def __init__(self, filename):
        self.filename = filename

    def increment(self):
        self.attemptcount += 1


class DownloadHandler(object):
    key = None
    secret = None
    token = None
    bucket_name = None
    owner = None
    group = None
    preserve = False
    target = None
    origin = None
    prefix = None
    force = False
    name = socket.getfqdn()
    fileset = []
    queue = Queue()
    num_threads = 4
    threads = {}

    def __init__(self, args):
        self.target = args.target[0]
        self.origin = args.origin[0]
        self.preserve = args.preserve
        self.key = args.gcs_key
        self.secret = args.aws_secret
        self.token = args.token
        self.bucket_name = args.bucket[0]
        self.num_threads = args.threads
        self.force = args.force
        if args.name:
            self.name = args.name
        self.prefix = '%s:%s' % (self.name, self.origin)

#       It may be a bit sub-optimal, but I rather fail sooner than later
        (owner, group) = self._build_file_set(args.file)

        if not self.preserve:
            owner = args.owner
            group = args.group

        # Use the correct Google Cloud Storage account if given
        if args.gcs_key:
            process = subprocess.Popen("gcloud auth activate-service-account --key-file %s" % (args.gcs_key), shell=True, stdout=subprocess.PIPE)
            process.communicate()
            if process.returncode != 0:
                log.debug("Unable to use GCS key %s" %(args.gcs_key))
                raise OSError('Unable to configure Gcloud with %s' %(args.gce_key))

        try:
            self.owner = pwd.getpwnam(owner).pw_uid
            self.group = grp.getgrnam(group).gr_gid
        except Exception as e:
            log.error(e)
            raise OSError('User/Group pair %s:%s does not exist' %
                (owner, group,))

    def _get_bucket(self):
        return self.bucket_name

    def _build_file_set(self, target_file=None):
        log.info('Building fileset')
        key = None
#       If you want to restore a file-set in particular
        bucket = self._get_bucket()
        if target_file:
            key = 'gs://%s/%s/%s-listdir.json' % (bucket, self.prefix, target_file)
#       Otherwise try to fetch the most recent one
        else:
            log.debug("gsutil ls -l gs://%s/%s/*.json" % (self.bucket_name, self.prefix))
            process = subprocess.Popen("gsutil ls -l gs://%s/%s/*.json 2> /dev/null | grep -v TOTAL" % (self.bucket_name,self.prefix), shell=True, stdout=subprocess.PIPE)
            process.wait()
            if process.returncode == 0:
                listdirs = process.stdout.read()
            else:
                log.debug("Unable to get listing for gs://%s/%s/" % (self.bucket_name, self.prefix))
            file_list=[]
            if listdirs:
                for listdir in StringIO.StringIO(listdirs):
                    listdir = listdir.strip()
                    last_modified = listdir.split(" ")[2]
                    file_name = listdir.split(" ")[4]
                    file_details = (file_name,time.mktime(time.strptime(last_modified, "%Y-%m-%dT%H:%M:%SZ")))
                    file_list.append(file_details)

                if file_list:
                    sorted_file_list = sorted(file_list,key=lambda x: x[1],reverse=True)
                    key = sorted_file_list[0][0]
                    log.debug("key %s" % (key))
            else:
                log.info("No files returned for gs://%s/%s/" % (self.bucket_name,self.prefix))

        if not key:
            raise LookupError('Cannot find anything to restore from %s:%s/%s' %
                (bucket.name, self.prefix, target_file or ''))

        log.debug("gsutil cat %s" % (key))
        process = subprocess.Popen("gsutil cat %s 2> /dev/null" % (key), shell=True, stdout=subprocess.PIPE)
        process.wait()
        if process.returncode == 0:
            json_data = json.loads(process.stdout.read())
            self.fileset = json_data[self.origin]
            log.info('Fileset contains %d files to download' % (len(self.fileset)))
        else:
            log.debug('Unable to get %s' % (key))

        return (0,0)

    def _test_permissions(self):
        log.info('Will now try to test writing to the target dir %s' %
            (self.target,))
        try:

            if os.path.isdir(self.target) == False:
                log.debug('Creating temp file in %s' % (self.target,))
                os.makedirs(self.target)
            log.debug('Changing owner:group for %s to %s:%s' %
                (self.target, self.owner, self.group,))

            os.chown(self.target, self.owner, self.group)
        except Exception as e:
            log.debug(e)
            log.exception('%s exists' % (self.target,))
        log.info('Will write to %s' % (self.target,))

    def _worker(self, idx, queue):
        log.info('Thread #%d processing items' % (idx, ))
        bucket = self._get_bucket()

        while queue.empty() == False:
            queueddownload = queue.get()
            fname = queueddownload.filename
            keypath = '%s/%s' % (self.prefix, fname,)
            destfile = os.path.join(self.target, os.path.basename(fname))

            log.debug('Thread #%d Checking if we need to download %s to %s' %
                (idx, keypath, destfile))

            if queueddownload.attemptcount < 5:
                download = False
                #Retry downloading until we succeed
                try:
                    key = "gs://%s/%s" % (bucket,keypath)
                    process = subprocess.Popen("gsutil stat %s 2> /dev/null" % (key), shell=True, stdout=subprocess.PIPE)
                    process.wait()
                    returncode = process.returncode
                    if returncode != 0:
                        raise Exception('Thread #%d key %s does not exist' %(idx,key))
                    else:
                        log.debug('Thread #%d Found key %s' % (idx,key))
                        m = re.search("Content-Length:\t+(\d+)", process.stdout.read())
                        if m:
                            key_size = int(m.group(1))
                        else:
                            raise Exception('Thread #%d unable get get stats for %s' % (idx, key))

                    if os.path.isfile(destfile):
                        stat = os.stat(destfile)
                        if self.force:
                            download = True
                        elif stat.st_size != key_size:
                            log.info('Thread #%d files %s and %s size differs, will '
                                're-download' % (idx, key, destfile,))
                            download = True
                    else:
                        download = True

                    if download and key:
                        log.info('Thread #%d downloading %s from %s to %s' %
                            (idx, fname, key, destfile))
                        process = subprocess.Popen("gsutil cp %s %s 2> /dev/null" % (key,destfile), shell=True, stdout=subprocess.PIPE)
                        process.wait()
                        if process.returncode != 0:
                            raise Exception('Thread #%d unable to download %s' % (idx, key))

                except Exception as e:
                    log.debug(e)
                    log.exception('Thread #%d Failed to download `%s` retrying' %
                        (idx, fname))
                    #We can't download, try again
                    queueddownload.increment()
                    queue.put(queueddownload)

            else:
                log.info('Thread #%d tried to download %s too many times.  Giving up' %
                    (idx, fname))

            #Pop the task regardless of state.  If it fails we've put it back
            queue.task_done()

        log.info('Thread #%d finished processing' % (idx))

    def run(self):
        self._test_permissions()
        log.info('Running')

        #queue up the filesets
        for filename in self.fileset:
            log.info('Pushing file %s onto queue' % filename)
            self.queue.put(DownloadCounter(filename))

#       launch threads and attach an event to them
        for idx in range(0, self.num_threads):
            self.threads[idx] = {}
#            e = threading.Event()
            t = threading.Thread(target=self._worker,
                kwargs={'idx': idx, 'queue': self.queue})
            t.setDaemon(True)
            self.threads[idx] = t
            t.start()

        #Wait for everything to finish downloading
        self.queue.join()
        log.info('My job is done.')


def main():
    p = pwd.getpwnam(os.environ['USER'])
    owner = p.pw_name
    group = [_.gr_name for _ in grp.getgrall() if _.gr_gid == p.pw_gid][0]
    ap = argparse.ArgumentParser(
        description='This is the companion script to the `tablesnap` program '
        'which you can use to restore files from an Amazon S3 bucket to any '
        'given local directory which you have write-permissions on. While the '
        'code is straightforward, the program assumes the files you are '
        'restoring got previously backed up with `tablesnap`',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    ap.add_argument('-k', '--gcs-key',
        default=os.environ.get('GCLOUD_KEY'),
        help='Google Cloud Storage Key (default from GCLOUD_KEY in environment)')
    ap.add_argument('-s', '--aws-secret',
        default=os.environ.get('AWS_SECRET_ACCESS_KEY'),
        help='Amazon S3 Secret (default from AWS_SECRET_ACCESS_KEY in environment)')
    ap.add_argument('--token',
        default=os.environ.get('AWS_SECURITY_TOKEN'),
        help='Amazon S3 Token (default from AWS_SECURITY_TOKEN in environment)')
    ap.add_argument('-p', '--preserve', default=False, action='store_true',
        help='Preserve the permissions (if they exist) from the source. '
        'This overrides -o and -g')
    ap.add_argument('-o', '--owner', default=owner,
        help='After download, chown files to this user.')
    ap.add_argument('-g', '--group', default=group,
        help='After download, chgrp files to this group.')
    ap.add_argument('-t', '--threads', type=int, default=4,
        help='Split the download between this many threads')
    ap.add_argument('-f', '--file',
        help='If specified, will download the file-set this file belongs to '
        'instead of the latest one available.')
    ap.add_argument('--force', default=False, action='store_true',
        help='Force download files even if they exist')
    ap.add_argument('-n', '--name', default=socket.getfqdn(),
        help='Use this name instead of the FQDN to prefix the bucket dir')
    ap.add_argument('bucket', nargs=1,
        help='S3 bucket to download files from')
    ap.add_argument('origin', nargs=1,
        help='Path inside the bucket to the directory you want to download '
        'files from')
    ap.add_argument('target', nargs=1,
        help='Path in the local FS where files should be downloaded to')
    args = ap.parse_args()
    dh = DownloadHandler(args)
    dh.run()

if __name__ == '__main__':
    sys.exit(main())
